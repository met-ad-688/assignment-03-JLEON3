---
title: Assignment 03
author:
  - name: Jonathan Leon
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-09-24'
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
  docx: default
  pdf: default  
date-modified: today
date-format: long
---

1 Load the Dataset
Load the Raw Dataset:
Use Pyspark to the lightcast_data.csv file into a DataFrame:
You can reuse the previous code.
Copying code from your friend constitutes plagiarism. DO NOT DO THIS.

```{python}
#| eval: true
#| echo: true
#| fig-align: center

import pandas as pd
import plotly.express as px
import plotly.io as pio
from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go
from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

np.random.seed(42)

pio.renderers.default = "vscode+notebook+png"

# Initialize Spark Session
spark = SparkSession.builder.appName("LightcastData").getOrCreate()

# Load Data
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("data/lightcast_job_postings.csv")
df.createOrReplaceTempView("job_postings")

# Show Schema and Sample Data
print("---This is Diagnostic check, No need to print it in the final doc---")

df.printSchema() # comment this line when rendering the submission
df.show(5)
```

# Data Preparation

```{python}
#Step 1: Casting salary and experience columns
df = df.withColumn("SALARY", col("SALARY").cast("float")) \
      .withColumn("SALARY_FROM", col("SALARY_FROM").cast("float")) \
      .withColumn("SALARY_TO", col("SALARY_TO").cast("float")) \
      .withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float")) \
      .withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))

# Step 2: Computing median for salary colums
def compute_median(sdf, col_name):
    q = sdf.approxQuantile(col_name, [0.5], 0.01)
    return q[0] if q else None

median_from = compute_median(df, "SALARY_FROM")
median_to = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")


print("Medians:", median_from, median_to, median_salary)

# Step 3: Imputing missing salaries, but not experience
df = df.fillna({
      "SALARY_FROM": median_from,
      "SALARY_TO": median_to,
      "SALARY": median_salary
})


# Step 4: Computing average salary
df = df.withColumn("Average_Salary", (col("SALARY_FROM") + col("SALARY_TO")) / 
2)

# Step 5: Selecting required columns
export_cols = [
    "EDUCATION_LEVELS_NAME",
    "REMOTE_TYPE_NAME",
    "MAX_YEARS_EXPERIENCE",
    "Average_Salary",
    "SALARY",
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME",
    "EMPLOYMENT_TYPE_NAME",
]


df_selected = df.select(*export_cols)


# Step 6: Saving to CSV
pdf = df_selected.toPandas()
pdf.to_csv("./data/lightcast_cleaned.csv", index=False)

print("Data cleaning complete. Rows retained:", len(pdf))

```

# Set Up Style Template
```{python}
import plotly.graph_objects as go
import plotly.io as pio

pio.templates["nike"] = go.layout.Template(
    # LAYOUT
    layout = {
        # Fonts
        # Note - 'family' must be a single string, NOT a list or dict!
        'title':
            {'font': {'family': 'HelveticaNeue-CondensedBold, Helvetica, Sans-serif',
                      'size':30,
                      'color': '#333'}
            },
        'font': {'family': 'Helvetica Neue, Helvetica, Sans-serif',
                      'size':16,
                      'color': '#333'},
        # Colorways
        'colorway': ['#ec7424', '#a4abab'],
        # Keep adding others as needed below
        'hovermode': 'x unified'
    },
    # DATA
    data = {
        # Each graph object must be in a tuple or list for each trace
        'bar': [go.Bar(texttemplate = '%{value:$.2s}',
                       textposition='outside',
                       textfont={'family': 'Helvetica Neue, Helvetica, Sans-serif',
                                 'size': 20,
                                 'color': '#FFFFFF'
                                 })]
    }
)


```



# Salary Distribution by Industry and Employment Type
Compare salary variations across industries.
Filter the dataset
  Remove records where salary is missing or zero.
Aggregate Data
  Group by NAICS industry codes.
  Group by employment type and compute salary distribution.
Visualize results
  Create a box plot where:
    X-axis = NAICS2_NAME
    Y-axis = SALARY_FROM
    Group by EMPLOYMENT_TYPE_NAME.
  Customize colors, fonts, and styles.
Explanation: Write two sentences about what the graph reveals.


```{python}
# Code for 1st question
import pandas as pd

# filter out missing or zero salary values
pdf = df.filter(df["SALARY"] > 0).select("EMPLOYMENT_TYPE_NAME", "SALARY").toPandas()
pdf = pdf[pdf["EMPLOYMENT_TYPE_NAME"].notnull()]

# Clean employment type names for better readability

pdf["EMPLOYMENT_TYPE_NAME"] = pdf["EMPLOYMENT_TYPE_NAME"].apply(lambda x: re.sub(r"[^\x00-\x7F]+", "", x))

# Compute median salary for sorting
median_salaries = pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()

#sort employment types based on median salary in descending order
sorted_employment_types = median_salaries.sort_values(ascending=False).index

# Apply sorted categories
pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(
    pdf["EMPLOYMENT_TYPE_NAME"],
    categories=sorted_employment_types,
    ordered=True
)

# Create box plot with horizontal grid lines
fig = px.box(
      pdf,
      x="EMPLOYMENT_TYPE_NAME",
      y="SALARY",
      title="Salary Distribution by Employment Type",
      # color_discrete_sequence=["black"], #single neutral color
      boxmode="group",
      points="all", #show all outliers
)

# Improve layout, font styles, and axis labels
fig.update_layout(template="nike")
    # title=dict(
    #       text="Salary Distribution by Employment Type",
    #       font=dict(size=30, family="Arial", color="black", weight="bold") #biggest & bold title
    # ),
    # xaxis=dict(
    #     title=dict(text="Employment Type", font=dict(size=14, family="Arial", color="black", weight="bold")),
    #     tickangle=0,
    #     tickfont=dict(size=12, family="arial", color="black", weight="bold"),
    #     showline=True,
    #     linewidth=2,
    #     linecolor="black",
    #     mirror=True,
    #     showgrid=False,
    #     categoryorder="array",
    #     categoryarray=sorted_employment_types.tolist()
    # ),
    # yaxis=dict(
    #     title=dict(text="Salary ($)", font=dict(size=14, family="Arial", color="black", weight="bold")),
    #     tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000],
    #     ticktext=["0", "50K", "100K", "150K", "200K", "250K", "300K", "350K", "400K", "450K", "500K"],
    #     tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    #     showline=True,
    #     linewidth=2,
    #     linecolor="black",
    #     mirror=True,
    #     showgrid=True,
    #     gridcolor="lightgray",
    #     gridwidth=0.5
    # ),
    # font=dict(family="Arial", size=12, color="black"),
    # boxgap=0.7,
    # plot_bgcolor="white",
    # paper_bgcolor="white",
    # showlegend=False,
    # height=500,
    # width=850,
# )

# Show the figure
fig.show()
# fig.write_html("output/Q1.html")
# fig.write_image("output/Q1.svg", width=850, height=500, scale=1)


```

```{python}
pdf = df.select("NAICS2_NAME", "SALARY_FROM").toPandas()
fig = px.box(pdf, x="NAICS2_NAME", y="SALARY_FROM", title="Salary Distribution by Industry")
fig.update_layout(template="nike")

fig.update_xaxes(tickangle=45)

fig.show()

# add back once final image created
#fig.write_html("output/Q1updated.html")
#fig.write_image("output/Q1updated.svg", width=850, height=500, scale=1)
```

fig.write_html("output/Q1updated.html")
fig.write_image("output/Q1updated.svg", width=850, height=500, scale=1)

# Salary Analysis by ONET Occupation Type (Bubble Chart)
Analyze how salaries differ across ONET occupation types.
Aggregate Data
  Compute median salary for each occupation in the ONET taxonomy.
Visualize results
  Create a bubble chart where:
    X-axis = ONET_NAME
    Y-axis = Median Salary
    Size = Number of job postings
  Apply custom colors and font styles.
Explanation: Write two sentences about what the graph reveals.




<!-- # Calculate median salary by ONET occupation
bubble_data = df.groupBy("ONET_NAME").agg(
    F.expr("percentile_approx(SALARY, 0.5)").alias("Median_Salary"),
    F.count("*").alias("Job_Postings_Count")
).toPandas()

# Create bubble chart
fig = px.scatter(
    bubble_data,
    x="ONET_NAME",
    y="Median_Salary",
    size="Job_Postings_Count",
    title="Median Salary by ONET Occupation"
)

fig.update_layout(template="nike")

fig.update_xaxes(tickangle=45)

fig.show()

# add back once final image created
#fig.write_html("output/Q1updated.html")
#fig.write_image("output/Q1updated.svg", width=850, height=500, scale=1) -->


```{python}

#Step 1: Spark SQL
salary_analysis = spark.sql("""
    SELECT
        LOT_OCCUPATION_NAME AS Occupation_Name,
        PERCENTILE(SALARY, 0.5) AS Median_Salary,
        COUNT(*) AS Job_Postings
    FROM job_postings
    GROUP BY LOT_OCCUPATION_NAME
    ORDER BY Job_Postings DESC
    LIMIT 10
    """)

#Step 2: Convert to Pandas DataFrame
salary_pd = salary_analysis.toPandas()
salary_pd.head()

```

```{python}
import plotly.express as px

fig = px.scatter(
      salary_pd,
      x="Occupation_Name",
      y="Median_Salary",
      size="Job_Postings",
      title="Salary Analysis by Lot Occupation Type (Bubble Chart)",
      labels={
          "LOT_OCCUPATION_NAME" : "Lot Occupation",
          "Median_Salary" : "Median Salary",
          "Job_Postings" : "Number of Job Postings"
      },
      hover_name="Occupation_Name",
      size_max=60,
      width=1000,
      height=600,
      color="Job_Postings",
      color_continuous_scale="Plasma"
)

fig.update_layout(template="nike")


```


# Salary by Education Level
Create two groups:
  Associate’s or lower (GED, Associate, No Education Listed)
  Bachelor’s (Bachelor’s degree)
  Master’s (Master’s degree)
  PhD (PhD, Doctorate, professional degree)
Plot scatter plots for each group using, MAX_YEARS_EXPERIENCE (with jitter), Average_Salary, LOT_V6_SPECIALIZED_OCCUPATION_NAME
After each graph, add a short explanation of key insights.

```{python}

#Create 2 Groups
lower_deg = ["Bachelor's", "Associate", "GED", "No Education Listed", "High school"]
higher_deg = ["Master's degree", "PhD or professional degree"]

# Add EDU_Group column
df = df.withColumn(
    "EDU_GROUP",
    when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in lower_deg])), "Bachelor's or lower")
    .when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in higher_deg])), "Master's or PhD")
)

df = df.withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))
df = df.withColumn("Average_Salary", col("Average_Salary").cast("float"))

df = df.filter(
    col("MAX_YEARS_EXPERIENCE").isNotNull() &
    col("Average_Salary").isNotNull() &
    (col("MAX_YEARS_EXPERIENCE") > 0) &
    (col("Average_Salary") > 0)
)

df_filtered = df.filter(col("EDU_GROUP").isin("Bachelor's or lower", "Master's or PhD"))

df_pd = df_filtered.toPandas()

```

```{python}

import numpy as np

# Add jitter to MAX_YEARS_EXPERIENCE
jitter_strength = 0.2
np.random.seed(42)
df_pd["MAX_YEARS_EXPERIENCE_JITTER"] = df_pd["MAX_YEARS_EXPERIENCE"] + np.random.uniform(-jitter_strength, jitter_strength, size=len(df_pd))

fig1 = px.scatter(
    df_pd,
    x="MAX_YEARS_EXPERIENCE_JITTER",
    y="Average_Salary",
    color="EDU_GROUP",
    hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
    title="<b>Experience vs Salary by Education Level</b>",
    opacity=0.7,
    width=800
)

fig1.update_traces(marker=dict(size=7, line=dict(width=1)))

fig1.update_layout(
  template="nike",
  font=dict(size=14),
  title_font=dict(size=22),
  xaxis_title="Years of Experience",
  yaxis_title="Average Salary (USD)",
  legend_title="Education Group",
  hoverlabel=dict(font_size=13),
  margin=dict(t=70, b=60, l=60, r=60,),
  xaxis=dict(
    tickmode='linear',
    dtick=1)
)

fig1.show()

```

```{python}
# Show unique values directly
df.select("REMOTE_TYPE_NAME").distinct().show()

```

# Salary by Remote Work Type
Split into three groups based on REMOTE_TYPE_NAME:
  Remote
  Hybrid
  Onsite (includes [None] and blank)
Plot scatter plots for each group using,  MAX_YEARS_EXPERIENCE (with jitter), Average_Salary, LOT_V6_SPECIALIZED_OCCUPATION_NAME
Also, create salary histograms for all three groups.
After each graph, briefly describe any patterns or comparisons.


remote_analysis = spark.sql("""
    SELECT
        remote_type_name AS Remote_Type,
        PERCENTILE(SALARY, 0.5) AS Median_Salary,
        COUNT(*) AS Job_Postings
    FROM job_postings
    GROUP BY LOT_OCCUPATION_NAME
    ORDER BY Job_Postings DESC
    LIMIT 10
    """)

#Step 2: Convert to Pandas DataFrame
salary_pd = salary_analysis.toPandas()
salary_pd.head()


```{python}
#Create 3 Groups
Remote = ["Remote"]
Hybrid = ["Hybrid Remote"]
Onsite = ["Not Remote", "\\[None\\]"]  # Escape the brackets since they're regex special characters

# Add REMOTE_Group column with corrected regex patterns
df = df.withColumn(
    "REMOTE_GROUP",
    when(col("REMOTE_TYPE_NAME").rlike("(?i)^Remote$"), "Remote")
    .when(col("REMOTE_TYPE_NAME").rlike("(?i)^Hybrid Remote$"), "Hybrid")
    .when(col("REMOTE_TYPE_NAME").rlike("(?i)^(Not Remote|\\[None\\])$"), "Onsite")
    .otherwise(None)  # This will help you see unmatched values
)

# Rest of your code remains the same
df = df.withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float"))
df = df.withColumn("Average_Salary", col("Average_Salary").cast("float"))

df = df.filter(
    col("MAX_YEARS_EXPERIENCE").isNotNull() &
    col("Average_Salary").isNotNull() &
    (col("MAX_YEARS_EXPERIENCE") > 0) &
    (col("Average_Salary") > 0)
)

df_filtered = df.filter(col("REMOTE_GROUP").isin("Remote", "Hybrid", "Onsite"))
df_remote = df_filtered.toPandas()


```


```{python}

import numpy as np

jitter_strength = 0.2
np.random.seed(42)
df_remote["MAX_YEARS_EXPERIENCE_JITTER"] = df_remote["MAX_YEARS_EXPERIENCE"] + np.random.uniform(-jitter_strength, jitter_strength, size=len(df_remote))

fig3 = px.scatter(
    df_remote,
    x="MAX_YEARS_EXPERIENCE_JITTER",
    y="Average_Salary",
    color="REMOTE_GROUP",
    hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
    title="<b>Experience vs Salary by Remote Work Type</b>",
    opacity=0.7,
    width=800
)

fig3.update_traces(marker=dict(size=7, line=dict(width=1)))

fig3.update_layout(
  template="nike",
  font=dict(size=14),
  title_font=dict(size=22),
  xaxis_title="Years of Experience",
  yaxis_title="Average Salary (USD)",
  legend_title="Remote Work Type",
  hoverlabel=dict(font_size=13),
  margin=dict(t=70, b=60, l=60, r=60,),
  xaxis=dict(
    tickmode='linear',
    dtick=1)
)

fig3.show()

```

```{python}

fig4 = px.box(df_remote, x="REMOTE_GROUP", y="SALARY_FROM", title="Salary Distribution by Industry")
fig4.update_layout(
  template="nike",
  xaxis_title="Remote Group",
  yaxis_title="Salary (USD)",
  )

fig4.show()
```

